# Визначення класу Teacher, що моделює викладача
class Teacher:
    """
    Клас, що представляє викладача та його кваліфікацію.
    Кожен викладач є потенційною "підмножиною" в задачі Покриття Множини,
    а предмети, які він викладає, - це елементи, які ця підмножина може "покрити".
    """
    # Конструктор класу для ініціалізації атрибутів викладача
    def __init__(self, first_name, last_name, age, email, can_teach_subjects):
        """Ініціалізує атрибути викладача."""
        self.first_name = first_name
        self.last_name = last_name
        self.age = age
        self.email = email
        # Множина предметів, які викладач може викладати (його "покриття")
        self.can_teach_subjects = can_teach_subjects
        # Множина предметів, які призначено викладати після роботи алгоритму
        self.assigned_subjects = set()

    # Метод для зручного відображення об'єкта (корисно для налагодження)
    def __repr__(self):
        """Представлення об'єкта для налагодження."""
        return f"Teacher({self.first_name} {self.last_name}, {self.age} років)"

# Основна функція, що реалізує жадібний алгоритм покриття множини

def create_schedule(subjects, teachers):
    """
    Створює розклад занять, використовуючи жадібний алгоритм, 
    з оптимізацією вибору за допомогою max() та lambda.
    """
    # Список для зберігання викладачів, обраних алгоритмом
    chosen_teachers = []
    # Створюємо копію початкової множини предметів, щоб відстежувати, які ще не покриті
    uncovered_subjects = subjects.copy()
    
    # Головний цикл алгоритму: продовжується, доки є непокриті предмети
    while uncovered_subjects:
        
        # 1. Визначення ключової функції для сортування/вибору
        # Ця лямбда-функція повертає кортеж для порівняння:
        # - Перший елемент: Кількість нових покритих предметів (ціль максимізації).
        # - Другий елемент: Негативний вік (-teacher.age), що забезпечує вибір 
        #   НАЙМОЛОДШОГО (найменше негативне число) у разі рівності покриття.
        selection_key = lambda teacher: (
            len(teacher.can_teach_subjects & uncovered_subjects), 
            -teacher.age
        )
        
        # 2. Використання max() для знаходження найкращого викладача за єдиним критерієм
        # max() автоматично знайде викладача, який максимізує перший елемент кортежу,
        # а потім, у разі рівності, максимізує другий (тобто мінімізує вік).
        best_teacher = max(teachers, key=selection_key)
        
        # Перевірка: кількість нових предметів, які покриває обраний найкращий викладач
        newly_covered_count = len(best_teacher.can_teach_subjects & uncovered_subjects)
        
        # Умова виходу: якщо найкращий викладач не покриває жодного НОВОГО предмету
        if newly_covered_count == 0:
            return None 

        # --- Оновлення стану ---
        # Визначаємо предмети, які призначаються цьому викладачу
        assigned_subjects = best_teacher.can_teach_subjects & uncovered_subjects
        
        # Додавання обраного викладача до списку рішення
        if best_teacher not in chosen_teachers:
            chosen_teachers.append(best_teacher)
        
        # Оновлюємо його призначені предмети
        best_teacher.assigned_subjects.update(assigned_subjects)

        # Видаляємо щойно покриті предмети з множини непокритих
        uncovered_subjects -= assigned_subjects 

    # Повертаємо список викладачів, які сформували мінімальне покриття
    return chosen_teachers

# Блок виконання, що запускається при прямому запуску файлу
if __name__ == '__main__':
    # --- Вхідні дані з технічних умов ---
    
    # Універсальна множина предметів (U)
    subjects = {'Математика', 'Фізика', 'Хімія', 'Інформатика', 'Біологія'}
    
    # Створення списку об'єктів Teacher (Набір підмножин S)
    teachers = [
        Teacher("Олександр", "Іваненко", 45, "o.ivanenko@example.com", {'Математика', 'Фізика'}),
        Teacher("Марія", "Петренко", 38, "m.petrenko@example.com", {'Хімія'}),
        Teacher("Сергій", "Коваленко", 50, "s.kovalenko@example.com", {'Інформатика', 'Математика'}),
        Teacher("Наталія", "Шевченко", 29, "n.shevchenko@example.com", {'Біологія', 'Хімія'}),
        Teacher("Дмитро", "Бондаренко", 35, "d.bondarenko@example.com", {'Фізика', 'Інформатика'}),
        Teacher("Олена", "Гриценко", 42, "o.grytsenko@example.com", {'Біологія'})
    ]

    # Виклик функції створення розкладу
    schedule = create_schedule(subjects, teachers)

    # --- Виведення результатів ---
    if schedule:
        print(" Розклад занять: ")
        print("--------------------------------------------------")        
        # Ітерація та виведення інформації про кожного обраного викладача
        for teacher in schedule:
            # Перетворюємо множину призначених предметів на відсортований список для красивого виведення
            assigned_list = sorted(list(teacher.assigned_subjects))
            
            print(f"{teacher.first_name} {teacher.last_name}, {teacher.age} років, email: {teacher.email}")
            print(f"   Викладає предмети: {', '.join(assigned_list)}")
            print("--------------------------------------------------")                    

    else:
        # Виведення повідомлення про невдачу покриття
        print("Неможливо покрити всі предмети наявними викладачами.")



# Інший варіант реалізації функції def create_schedule - підхід: Ітеративний цикл for (Явна логіка)

# def create_schedule(subjects, teachers):
#     """
#     Створює розклад занять, використовуючи жадібний алгоритм для мінімізації
#     кількості необхідних викладачів, які покривають всі предмети.

#     :param subjects: Множина всіх предметів (Універсальна множина U).
#     :param teachers: Список об'єктів Teacher (Набір підмножин S).
#     :return: Список обраних об'єктів Teacher з призначеними предметами, або None.
#     """
#     # Список для зберігання викладачів, обраних алгоритмом
#     chosen_teachers = []
#     # Створюємо копію початкової множини предметів, щоб відстежувати, які ще не покриті
#     uncovered_subjects = subjects.copy()
    
#     # Головний цикл алгоритму: продовжується, доки є непокриті предмети
#     while uncovered_subjects:
#         # Ініціалізація змінних для відстеження найкращого вибору на поточному кроці
#         best_teacher = None
#         max_newly_covered = -1
        
#         # Ітерація по всіх доступних викладачах, щоб знайти найкращу "підмножину"
#         for teacher in teachers:
#             # Обчислення перетину: знаходить предмети, які викладач може викладати 
#             # І які ще НЕ покриті (жадібний вибір)
#             newly_covered = teacher.can_teach_subjects & uncovered_subjects
#             # Кількість нових предметів, які покриває цей викладач
#             num_newly_covered = len(newly_covered)

#             # Перевірка головного критерію жадібного алгоритму:
#             # Чи покриває цей викладач найбільшу кількість НОВИХ непокритих предметів?
#             if num_newly_covered > max_newly_covered:
#                 max_newly_covered = num_newly_covered
#                 best_teacher = teacher
#             # Правило тай-брейку: якщо покривають однакову кількість нових предметів
#             elif num_newly_covered == max_newly_covered and best_teacher is not None:
#                 # Обираємо наймолодшого викладача серед рівних за критерієм покриття
#                 if num_newly_covered > 0 and teacher.age < best_teacher.age:
#                     best_teacher = teacher

#         # Умова, що сигналізує про неможливість покриття:
#         # Якщо ми не знайшли жодного викладача, який покриває хоча б один новий предмет,
#         # але непокриті предмети ще залишилися.
#         if max_newly_covered == 0:
#             # Повертаємо None, щоб вказати на невдачу повного покриття
#             return None 

#         # Додавання обраного викладача до списку рішення (якщо він ще не був обраний)
#         if best_teacher not in chosen_teachers:
#             chosen_teachers.append(best_teacher)
        
#         # Визначаємо, які саме предмети призначаються цьому викладачу на цьому кроці
#         assigned_subjects = best_teacher.can_teach_subjects & uncovered_subjects
        
#         # Оновлюємо атрибут викладача, додаючи призначені йому предмети
#         best_teacher.assigned_subjects.update(assigned_subjects)

#         # Видаляємо щойно покриті предмети з множини непокритих
#         # Це зменшує проблему для наступної ітерації
#         uncovered_subjects -= assigned_subjects

#     # Після завершення циклу, якщо ми тут, це означає, що всі предмети покриті
#     if not uncovered_subjects:
#         # Повертаємо список викладачів, які сформували мінімальне покриття
#         return chosen_teachers
#     else:
#         # Ця гілка є резервною, але показує, що покриття не відбулося
#         return None 


# Порівняння Підходів Реалізації функції create_schedule

# Обидва підходи реалізують жадібний алгоритм покриття множини і досягають однакового результату, 
# але використовують різний стиль кодування. 

# 1 Підхід: Ітеративний цикл for (Явна логіка)
# •	Метод: Явне порівняння з використанням конструкцій if та elif всередині циклу for, що перебирає викладачів.
# •	Стиль коду: Імперативний. Фокусується на тому, як крок за кроком виконувати порівняння.
# •	Реалізація критеріїв: Логіка двох рівнів: спочатку перевірка на найбільше покриття (if), 
#     потім окрема перевірка на найменший вік (тай-брейк через elif).
# •	Лаконічність: Низька. Код багатослівний, вимагає ручного керування проміжними змінними (best_teacher, max_newly_covered).
# •	Плюси: Прозорість та очевидність логіки порівняння — зрозумілий для початківців.
# •	Мінуси: Багатослівність і менша гнучкість при додаванні нових критеріїв. 

# 2 Підхід: Функція max() з  lambda-функцією (Декларативна логіка)
# •	Метод: Неявне порівняння за допомогою вбудованої функції max, яка використовує ключову lambda-функцію.
# •	Стиль коду: Декларативний та "пітонічний". Фокусується на тому, що потрібно максимізувати, а не як це робити.
# •	Реалізація критеріїв: Усі критерії інкапсульовані в одному кортежі (покриття, -вік). 
#     Функція max автоматично виконує лексикографічне сортування (спочатку покриття, потім вік).
# •	Лаконічність: Висока. Замінює цілий блок порівняння кількома рядками коду.
# •	Плюси: Елегантність, компактність та відповідність кращим практикам Python. 
#     Швидке розширення критеріїв (додавання елементів до кортежу).
# •	Мінуси: Абстрактність логіки кортежного сортування може бути менш очевидною для тих, хто тільки починає вивчати Python.

# Загальний Висновок
# Підхід max з lambda-функцією та кортежем є кращим вибором. 
# Він ефективно використовує вбудовані можливості Python для вирішення 
# задачі сортування за кількома пріоритетами (покриття, потім вік), 
# перетворюючи імперативну логіку на компактний декларативний вираз.


