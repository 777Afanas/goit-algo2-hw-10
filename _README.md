# Завдання 1. Оптимізація доступу до даних за допомогою LRU-кешу



Реалізуйте програму, що демонструє, як LRU-кеш пришвидшує багаторазові «гарячі» запити до великого масиву чисел.



### Технічні умови

1. Маємо масив array довжиною N зі строго додатних цілих чисел (1 ≤ N ≤ 100 000). Необхідно обробити Q запитів (1 ≤ Q ≤ 50 000) двох типів

Range(L, R) — обчислити суму елементів array[L : R + 1].
Update(index, value) — присвоїти array[index] ← value.


2. Реалізуйте чотири функції

`range_sum_no_cache(array, left, right)` — повертає суму без кешування.

`update_no_cache(array, index, value)` — оновлює елемент без кешування. 

`range_sum_with_cache(array, left, right)` — виконує пошук у готовому класі 
LRUCache (ємність K = 1000). Якщо cache.get() повертає −1 (cache-miss),  
обчислює суму, зберігає її методом put() і повертає результат. 

`update_with_cache(array, index, value)` — оновлює масив і видаляє всі  
діапазони з кешу, що містять змінений index. Інвалідація здійснюється 
лінійним проходом по ключах кешу — іншої модифікації класу не потрібно.

3. Для тестування використайте функцію, яка створює список із 50 000 запитів до масиву з 100 000 елементів. Три відсотки — це оновлення окремих елементів, решта — запити на підрахунок суми. Для більшості таких Range-запитів (95 %) обирається один із тридцяти заздалегідь випадково визначених «гарячих» діапазонів, тобто вони багаторазово повторюються протягом тесту. Решта запитів (5 %) формуються повністю випадковим чином.

Така модель максимально наближена до реальних сценаріїв із популярними й рідкісними діапазонами, що дозволяє оцінити користь кешу саме в умовах повторюваного доступу.


Пояснення параметрів:

`n` — розмір масиву, для цього завдання використовуйте n = 100_000.

`q` — кількість запитів у тесті, для цього завдання використовуйте q = 50_000.

`hot_pool` — кількість «гарячих» (часто використовуваних) діапазонів, тобто тих відрізків, до яких запити будуть надходити найчастіше. За замовчуванням 30.

`p_hot` — ймовірність, що новий запит типу Range буде взято саме з цього «гарячого» пулу. У нашій моделі це 95 %, тобто практично всі Range-запити дублюють популярні діапазони.

`p_update` — частка запитів, які є оновленням значення елемента. У нашому прикладі 3 % (решта 97 % — це запити на суму).



4. Виміряйте час виконання всієї послідовності запитів двічі — без кешу та з кешем — і виведіть результати у зрозумілому текстовому вигляді. 

### Критерії прийняття
Усі функції: `range_sum_no_cache, update_no_cache, range_sum_with_cache, update_with_cache` — реалізовані та працюють.
Програма вимірює час виконання запитів з кешем і без нього та виводить результати у зрозумілому вигляді.
Результати тестування представлені у зручному для розуміння форматі, щоб можна було оцінити ефективність використання LRU-кешу.
Код виконується без помилок і відповідає технічним вимогам.



# Завдання 2. Реалізація Rate Limiter з використанням алгоритму Sliding Window для обмеження частоти повідомлень у чаті



У чат-системі необхідно реалізувати механізм обмеження частоти повідомлень від користувачів для запобігання спаму. Реалізація повинна використовувати алгоритм Sliding Window для точного контролю часових інтервалів, який дозволяє відстежувати кількість повідомлень у заданому часовому вікні й обмежувати користувачів у надсиланні повідомлень, якщо ліміт перевищено.



### Технічні умови

1. Реалізація повинна використовувати алгоритм Sliding Window для точного контролю часових інтервалів.

2. Базові параметри системи: розмір вікна (window_size) — 10 секунд і максимальна кількість повідомлень у вікні (max_requests) — 1.

3. Реалізуйте клас SlidingWindowRateLimiter.

4. Реалізуйте методи класу:

`_cleanup_window` — для очищення застарілих запитів з вікна та оновлення 
 активного часового вікна; 

`can_send_message` — для перевірки можливості відправлення повідомлення 
 в поточному часовому вікні; 

`record_message` — для запису нового повідомлення й оновлення історії 
 користувача;
 
 `time_until_next_allowed` — для розрахунку часу очікування до можливості 
  відправлення наступного повідомлення. 


5. Структура даних для зберігання історії повідомлень — collections.deque.



### Критерії прийняття

1. При спробі відправити повідомлення раніше ніж через 10 секунд повертається методом can_send_message значення False.

2. При першому повідомленні від користувача завжди повертається True.

3. При видаленні всіх повідомлень з вікна користувача видаляється запис про користувача зі структури даних.

4. Метод `time_until_next_allowed` повертає час очікування в секундах.

5. Тестова функція згідно з прикладом прогнана й працює відповідно до очікувань.